{
  "language": "Solidity",
  "sources": {
    "contracts/Auth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nabstract contract Auth {\n\n    event SetOwner(address indexed owner);\n    event SetTrusted(address indexed user, bool isTrusted);\n\n    address public owner;\n\n    mapping(address => bool) public trusted;\n\n    error OnlyOwner();\n    error OnlyTrusted();\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert OnlyOwner();\n        _;\n    }\n\n    modifier onlyTrusted() {\n        if (!trusted[msg.sender]) revert OnlyTrusted();\n        _;\n    }\n\n    constructor(address newOwner, address trustedUser) {\n        owner = newOwner;\n        trusted[trustedUser] = true;\n\n        emit SetOwner(owner);\n        emit SetTrusted(trustedUser, true);\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit SetOwner(newOwner);\n    }\n\n    function setTrusted(address user, bool isTrusted) external onlyOwner {\n        trusted[user] = isTrusted;\n        emit SetTrusted(user, isTrusted);\n    }\n\n}\n"
    },
    "contracts/Unwindooor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./Auth.sol\";\nimport \"./uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"./uniswapv2/interfaces/IUniswapV2Factory.sol\";\n\n/// @notice Contract for withdrawing LP positions.\n/// @dev Calling unwindPairs() withdraws the LP position into one of the two tokens\ncontract Unwindooor is Auth {\n\n    error SlippageProtection();\n    error TransferFailed();\n\n    bytes4 private constant TRANSFER_SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    IUniswapV2Factory public immutable factory;\n\n    constructor(\n        address owner,\n        address user,\n        address factoryAddress\n    ) Auth(owner, user) {\n        factory = IUniswapV2Factory(factoryAddress);\n    }\n\n    // We remove liquidity and sell tokensB[i] for tokensA[i].\n    function unwindPairs(\n        address[] calldata tokensA,\n        address[] calldata tokensB,\n        uint256[] calldata amounts,\n        uint256[] calldata minimumOuts\n    ) external onlyTrusted {\n        for (uint256 i = 0; i < tokensA.length; i++) {\n            \n            address tokenA = tokensA[i];\n            address tokenB = tokensB[i];\n            bool keepToken0 = tokenA < tokenB;\n            address pair = _pairFor(tokenA, tokenB);\n\n            if (_unwindPair(IUniswapV2Pair(pair), amounts[i], keepToken0, tokenB) < minimumOuts[i]) revert SlippageProtection();\n        }\n    }\n\n    // Burn liquidity and sell one of the tokens for the other.\n    function _unwindPair(\n        IUniswapV2Pair pair,\n        uint256 amount,\n        bool keepToken0,\n        address tokenToSell\n    ) private returns (uint256 amountOut) {\n\n        pair.transfer(address(pair), amount);\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n\n        if (keepToken0) {\n            _safeTransfer(tokenToSell, address(pair), amount1);\n            amountOut = _getAmountOut(amount1, uint256(reserve1), uint256(reserve0));\n            pair.swap(amountOut, 0, address(this), \"\");\n            amountOut += amount0;\n        } else {\n            _safeTransfer(tokenToSell, address(pair), amount0);\n            amountOut = _getAmountOut(amount0, uint256(reserve0), uint256(reserve1));\n            pair.swap(0, amountOut, address(this), \"\");\n            amountOut += amount1;\n        }\n    }\n\n    // In case we don't want to sell one of the tokens for the other.\n    function burnPairs(\n        IUniswapV2Pair[] calldata lpTokens,\n        uint256[] calldata amounts,\n        uint256[] calldata minimumOut0,\n        uint256[] calldata minimumOut1\n    ) external onlyTrusted {\n        for (uint256 i = 0; i < lpTokens.length; i++) {\n            IUniswapV2Pair pair = lpTokens[i];\n            pair.transfer(address(pair), amounts[i]);\n            (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n            if (amount0 < minimumOut0[i] || amount1 < minimumOut1[i]) revert SlippageProtection();\n        }\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n        return numerator / denominator;\n    }\n\n    function _safeTransfer(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(TRANSFER_SELECTOR, to, value));\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) revert TransferFailed();\n    }\n\n    function _pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex'ae079abb028d7260907dc9ddcc6b31a091e085bc4b9259cd816d3fa5f001953d' // init code hash\n        )))));\n    }\n\n}\n"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/uniswapv2/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"
    },
    "contracts/uniswapv2/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IERC20Uniswap {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "contracts/PowMaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./WethMaker.sol\";\nimport \"./uniswapv2/interfaces/IERC20.sol\";\n\n/// @notice Contract for selling weth to pow. Deploy on mainnet.\ncontract PowMaker is WethMaker {\n\n    event Serve(uint256 amount);\n\n    address public immutable pow;\n    address public immutable sPow;\n\n    constructor(\n        address owner,\n        address user,\n        address factory,\n        address weth,\n        address _pow,\n        address _sPow\n    ) WethMaker(owner, user, factory, weth) {\n        pow = _pow;\n        sPow = _sPow;\n    }\n\n    function buyPow(uint256 amountIn, uint256 minOutAmount) external onlyTrusted returns (uint256 amountOut) {\n        amountOut = _swap(weth, pow, amountIn, sPow);\n        if (amountOut < minOutAmount) revert SlippageProtection();\n        emit Serve(amountOut);\n    }\n\n    function sweep(uint256 amount) external onlyTrusted {\n        IERC20Uniswap(pow).transfer(sPow, amount);\n        emit Serve(amount);\n    }\n\n    // In case we receive any unwrapped ethereum we can call this.\n    function wrapEth() external {\n        weth.call{value: address(this).balance}(\"\");\n    }\n\n}\n"
    },
    "contracts/WethMaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./Unwindooor.sol\";\n\n/// @notice Contract for selling received tokens into weth. Deploy on secondary networks.\ncontract WethMaker is Unwindooor {\n\n    event SetBridge(address indexed token, address bridge);\n\n    address public immutable weth;\n\n    mapping(address => address) public bridges;\n\n    constructor(\n        address owner,\n        address user,\n        address factory,\n        address _weth\n    ) Unwindooor(owner, user, factory) {\n        weth = _weth;\n    }\n\n    function setBridge(address token, address bridge) external onlyOwner {\n        bridges[token] = bridge;\n        emit SetBridge(token, bridge);\n    }\n\n    // Exchange token for weth or its bridge token (which gets converted into weth in subsequent transactions).\n    function buyWeth(\n        address[] calldata tokens,\n        uint256[] calldata amountsIn,\n        uint256[] calldata minimumOuts\n    ) external onlyTrusted {\n        for (uint256 i = 0; i < tokens.length; i++) {\n\n            address tokenIn = tokens[i];\n            address outToken = bridges[tokenIn] == address(0) ? weth : bridges[tokenIn];\n            if (_swap(tokenIn, outToken, amountsIn[i], address(this)) < minimumOuts[i]) revert SlippageProtection();\n            \n        }\n    }\n\n    function _swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address to\n    ) internal returns (uint256 outAmount) {\n\n        IUniswapV2Pair pair = IUniswapV2Pair(_pairFor(tokenIn, tokenOut));\n        _safeTransfer(tokenIn, address(pair), amountIn);\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        if (tokenIn < tokenOut) {\n\n            outAmount = _getAmountOut(amountIn, reserve0, reserve1);\n            pair.swap(0, outAmount, to, \"\");\n\n        } else {\n\n            outAmount = _getAmountOut(amountIn, reserve1, reserve0);\n            pair.swap(outAmount, 0, to, \"\");\n\n        }\n\n    }\n\n    // Allow the owner to withdraw the funds and bridge them to mainnet.\n    function withdraw(address token, address to, uint256 _value) onlyOwner external {\n        if (token != address(0)) {\n            _safeTransfer(token, to, _value);\n        } else {\n            (bool success, ) = to.call{value: _value}(\"\");\n            require(success);\n        }\n    }\n\n    function doAction(address to, uint256 _value, bytes memory data) onlyOwner external {\n        (bool success, ) = to.call{value: _value}(data);\n        require(success);\n    }\n\n    receive() external payable {}\n\n}\n"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/uniswapv2/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}